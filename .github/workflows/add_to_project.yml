name: Auto Add Issue to Project

on:
  issues:
    types: [opened, edited]

jobs:
  add-to-project:
    runs-on: ubuntu-latest
    steps:
      - name: Add to Project (best-effort)
        uses: actions/add-to-project@v0.5.0
        id: add-project
        with:
          project-url: https://github.com/orgs/aptma-sHEWTeam/projects/3
          github-token: ${{ secrets.ORG_PROJECTS_TOKEN }}

      - name: Debug - Show add-project outputs
        run: |
          echo "Item ID: ${{ steps.add-project.outputs.itemId }}"
          echo "All outputs: ${{ toJson(steps.add-project.outputs) }}"

      - name: Extract Issue Fields (robust)
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const raw = context.payload.issue.body || '';
            const text = raw.replace(/\r\n/g, '\n'); // normalize newline
            const lines = text.split('\n');

            // 期待ラベルとエイリアス（大小文字無視）
            const wanted = new Map([
              ['role', ['role']],
              ['team', ['programteam', 'team']],
              ['priority', ['priority']],
              ['component', ['component']],
              ['size', ['size']],
              ['estimate', ['estimate', 'estimate (時間)']],
              ['start_date', ['start date', 'start date (yyyy-mm-dd)']],
              ['due_date', ['end date', 'due date', 'end date (yyyy-mm-dd)']],
            ]);

            const values = {
              role: '', team: '', priority: '', component: '', size: '', estimate: '', start_date: '', due_date: ''
            };

            function norm(s) { return (s || '').trim().toLowerCase(); }

            for (let i = 0; i < lines.length; i++) {
              const label = norm(lines[i]);
              if (!label) continue;
              for (const [key, aliases] of wanted.entries()) {
                if (aliases.some(a => label === a)) {
                  // 次の非空行を値として拾う
                  let j = i + 1; let val = '';
                  while (j < lines.length) {
                    const v = lines[j].trim();
                    j++;
                    if (v.length === 0) continue;
                    val = v; break;
                  }
                  if (val.length > 0) { values[key] = val; }
                }
              }
            }

            console.log('Extracted:', values);
            for (const [k, v] of Object.entries(values)) core.setOutput(k, v);

      - name: Debug - Show extracted fields
        run: |
          echo "Role: ${{ steps.extract.outputs.role }}"
          echo "Team: ${{ steps.extract.outputs.team }}"
          echo "Priority: ${{ steps.extract.outputs.priority }}"
          echo "Component: ${{ steps.extract.outputs.component }}"
          echo "Size: ${{ steps.extract.outputs.size }}"
          echo "Estimate: ${{ steps.extract.outputs.estimate }}"
          echo "Start Date: ${{ steps.extract.outputs.start_date }}"
          echo "Due Date: ${{ steps.extract.outputs.due_date }}"

      - name: Get Project Data (find or add)
        uses: actions/github-script@v7
        id: project-data
        with:
          github-token: ${{ secrets.ORG_PROJECTS_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const org = 'aptma-sHEWTeam';
            const projectNumber = 3;

            const pageQuery = `
              query($org: String!, $number: Int!, $first: Int!, $after: String) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    items(first: $first, after: $after) {
                      nodes { id content { ... on Issue { id number } } }
                      pageInfo { hasNextPage endCursor }
                    }
                    fields(first: 50) {
                      nodes {
                        ... on ProjectV2Field { id name dataType }
                        ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                      }
                    }
                  }
                }
              }
            `;

            const addMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                  item { id }
                }
              }
            `;

            async function findItemAndFields() {
              let after = null; let project = null;
              while (true) {
                const res = await github.graphql(pageQuery, { org, number: projectNumber, first: 100, after });
                project = res.organization.projectV2;
                const hit = project.items.nodes.find(n => n.content && n.content.number === issue.number);
                if (hit) return { project, itemId: hit.id };
                const pi = project.items.pageInfo;
                if (!pi.hasNextPage) return { project, itemId: null };
                after = pi.endCursor;
              }
            }

            // 1) 探す
            let { project, itemId } = await findItemAndFields();
            const projectId = project.id;

            // 2) 無ければ追加して再検索
            if (!itemId) {
              console.log('Item not found, adding via GraphQL...');
              try {
                const addRes = await github.graphql(addMutation, { projectId, contentId: issue.node_id });
                console.log('Added item id:', addRes.addProjectV2ItemById.item.id);
              } catch (e) {
                console.log('Add mutation error (may already exist):', e.message);
              }
              // 少し待機してから再検索
              await new Promise(r => setTimeout(r, 1500));
              ({ project, itemId } = await findItemAndFields());
              if (!itemId) throw new Error('Could not find or add issue to project');
            }

            // 出力
            core.setOutput('item_id', itemId);
            core.setOutput('project_id', projectId);

            const fields = {}; const fieldOptions = {};
            for (const f of project.fields.nodes) {
              fields[f.name] = f.id;
              if (f.options) {
                const map = {}; for (const o of f.options) map[o.name] = o.id; fieldOptions[f.name] = map;
              }
            }
            core.setOutput('fields', JSON.stringify(fields));
            core.setOutput('field_options', JSON.stringify(fieldOptions));

      - name: Set Project Fields
        uses: actions/github-script@v7
        if: steps.project-data.outputs.item_id
        env:
          PROJECT_ID: ${{ steps.project-data.outputs.project_id }}
          ITEM_ID: ${{ steps.project-data.outputs.item_id }}
          FIELDS: ${{ steps.project-data.outputs.fields }}
          FIELD_OPTIONS: ${{ steps.project-data.outputs.field_options }}
          ROLE: ${{ steps.extract.outputs.role }}
          TEAM: ${{ steps.extract.outputs.team }}
          PRIORITY: ${{ steps.extract.outputs.priority }}
          COMPONENT: ${{ steps.extract.outputs.component }}
          SIZE: ${{ steps.extract.outputs.size }}
          ESTIMATE: ${{ steps.extract.outputs.estimate }}
          START_DATE: ${{ steps.extract.outputs.start_date }}
          DUE_DATE: ${{ steps.extract.outputs.due_date }}
        with:
          github-token: ${{ secrets.ORG_PROJECTS_TOKEN }}
          script: |
            const projectId = process.env.PROJECT_ID;
            const itemId = process.env.ITEM_ID;
            const fields = JSON.parse(process.env.FIELDS);
            const fieldOptions = JSON.parse(process.env.FIELD_OPTIONS);
            const SKIP = new Set(['', '_No response_', 'No response', 'Choose an option', 'None', 'No date', 'Enter number...']);

            // 正規化マップ（フィールド名の大文字小文字/前後空白無視）
            const fieldIdByName = new Map();
            for (const [name, id] of Object.entries(fields)) {
              fieldIdByName.set(name.trim().toLowerCase(), id);
            }
            const optionIdByFieldName = new Map();
            for (const [fname, opts] of Object.entries(fieldOptions)) {
              const map = new Map();
              for (const [optName, optId] of Object.entries(opts || {})) {
                map.set(optName.trim().toLowerCase(), optId);
              }
              optionIdByFieldName.set(fname.trim().toLowerCase(), map);
            }

            console.log('Available fields:', Array.from(fieldIdByName.keys()));

            function getFieldId(fieldName) {
              const id = fieldIdByName.get(fieldName.trim().toLowerCase());
              if (!id) console.log(`Field not found: '${fieldName}'. Available=`, Array.from(fieldIdByName.keys()));
              return id;
            }

            function getOptionId(fieldName, value) {
              const opts = optionIdByFieldName.get(fieldName.trim().toLowerCase());
              if (!opts) { console.log(`Options not found map for field '${fieldName}'`); return null; }
              const id = opts.get(value.trim().toLowerCase());
              if (!id) console.log(`Option not found: '${fieldName}' -> '${value}'. Available=`, Array.from(opts.keys()));
              return id;
            }

            async function setSingleSelect(fieldName, value) {
              if (SKIP.has(value)) { console.log(`Skip ${fieldName}: '${value}'`); return; }
              const fieldId = getFieldId(fieldName); if (!fieldId) return;
              const optId = getOptionId(fieldName, value); if (!optId) return;
              await github.graphql(`mutation { updateProjectV2ItemFieldValue(input: { projectId: "${projectId}", itemId: "${itemId}", fieldId: "${fieldId}", value: { singleSelectOptionId: "${optId}" } }) { projectV2Item { id } } }`);
              console.log(`? Set ${fieldName}: ${value}`);
            }

            async function setDate(fieldName, value) {
              if (SKIP.has(value)) { console.log(`Skip ${fieldName}: '${value}'`); return; }
              if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) { console.log(`Skip ${fieldName}: invalid date '${value}'`); return; }
              const fieldId = getFieldId(fieldName); if (!fieldId) return;
              await github.graphql(`mutation { updateProjectV2ItemFieldValue(input: { projectId: "${projectId}", itemId: "${itemId}", fieldId: "${fieldId}", value: { date: "${value}" } }) { projectV2Item { id } } }`);
              console.log(`? Set ${fieldName}: ${value}`);
            }

            async function setNumber(fieldName, value) {
              if (SKIP.has(value)) { console.log(`Skip ${fieldName}: '${value}'`); return; }
              const n = parseFloat(value); if (isNaN(n)) { console.log(`Skip ${fieldName}: NaN '${value}'`); return; }
              const fieldId = getFieldId(fieldName); if (!fieldId) return;
              await github.graphql(`mutation { updateProjectV2ItemFieldValue(input: { projectId: "${projectId}", itemId: "${itemId}", fieldId: "${fieldId}", value: { number: ${n} } }) { projectV2Item { id } } }`);
              console.log(`? Set ${fieldName}: ${n}`);
            }

            await setSingleSelect('Role', process.env.ROLE);
            await setSingleSelect('ProgramTeam', process.env.TEAM);
            await setSingleSelect('Priority', process.env.PRIORITY);
            await setSingleSelect('Component', process.env.COMPONENT);
            await setSingleSelect('Size', process.env.SIZE);
            await setNumber('Estimate', process.env.ESTIMATE);
            await setDate('Start date', process.env.START_DATE);
            await setDate('End date', process.env.DUE_DATE);

            console.log('? All fields processed')
